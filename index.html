<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../assets/style.css">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>

<body>
    <div class="container">
        <div class="item">Привет, ты чо</div>
        <div class="item">Чо как</div>
        <div class="item">3</div>
        <div class="item">4</div>
        <div class="item">Ха-ха</div>
        <div class="item">Почему</div>
        <div class="item">7</div>
        <div class="item">Я дурею</div>
        <div class="item">С этой прикормки</div>
        <div class="item">8</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">GPGPGPGPPG</div>
        <div class="item"></div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>
        <div class="item">JKlkj</div>

    </div>

    <style>
        .container {
            display: grid;
            grid-gap: 60px;
            grid-template-columns: 200px 300px 200px 300px 400px 300px 200px 300px;
            grid-template-rows: 200px 200px 300px;
            grid-auto-rows: 200px;
            grid-auto-columns: 100px;
        }
    </style>

    <script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

    <script type="module">

        import * as THREE from 'three';

        import { ParallaxBarrierEffect } from 'three/addons/effects/ParallaxBarrierEffect.js';

        let container, camera, scene, renderer, effect;

        const spheres = [];

        let mouseX = 0;
        let mouseY = 0;

        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;

        document.addEventListener('mousemove', onDocumentMouseMove);

        init();

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.01, 100);
            camera.position.z = 3;

            const path = 'textures/cube/pisa/';
            const format = '.png';
            const urls = [
                path + 'px' + format, path + 'nx' + format,
                path + 'py' + format, path + 'ny' + format,
                path + 'pz' + format, path + 'nz' + format
            ];

            const textureCube = new THREE.CubeTextureLoader().load(urls);

            scene = new THREE.Scene();
            scene.background = textureCube;

            const geometry = new THREE.SphereGeometry(0.1, 100, 100);
            const material = new THREE.MeshBasicMaterial({ color: 0xf00000, envMap: textureCube });

            for (let i = 0; i < 500; i++) {

                const mesh = new THREE.Mesh(geometry, material);

                mesh.position.x = Math.random() * 50 - 5;
                mesh.position.y = Math.random() * 10 - 5;
                mesh.position.z = Math.random() * 10 - 5;

                mesh.scale.x = mesh.scale.y = mesh.scale.z = Math.random() * 2 + 1;

                scene.add(mesh);

                spheres.push(mesh);

            }

            //

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setAnimationLoop(animate);
            container.appendChild(renderer.domElement);

            const width = window.innerWidth || 2;
            const height = window.innerHeight || 2;

            effect = new ParallaxBarrierEffect(renderer);
            effect.setSize(width, height);

            //

            window.addEventListener('resize', onWindowResize);

        }

        function onWindowResize() {

            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            effect.setSize(window.innerWidth, window.innerHeight);

        }

        function onDocumentMouseMove(event) {

            mouseX = (event.clientX - windowHalfX) / 100;
            mouseY = (event.clientY - windowHalfY) / 100;

        }

        //

        function animate() {

            const timer = 0.0001 * Date.now();

            camera.position.x += (mouseX - camera.position.x) * .05;
            camera.position.y += (- mouseY - camera.position.y) * .05;

            camera.lookAt(scene.position);

            for (let i = 0, il = spheres.length; i < il; i++) {

                const sphere = spheres[i];

                sphere.position.x = 5 * Math.cos(timer + i);
                sphere.position.y = 5 * Math.sin(timer + i * 1.1);

            }

            effect.render(scene, camera);

        }

    </script>

</body>

</html>
